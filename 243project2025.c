
/*******************************************************************
 * 3D FPS MAZE SHOOTER
 * MARK PIRNER AND ARYAN BILLAH
 *
 * USING 3D RAYCASTING, A 3D ENVIRONMENT WAS MADE WHERE THE USER WILL TRAVERSE
 * AND FIND ENEMIES TO SHOOT. KILL ENOUGH ENEMIES IN TIME TO WIN, BUT RUN OUT
 * OF TIME OR GET HIT AND YOU LOSE!
 *
 * SOME FUNCTIONS BELOW ARE NOT USED FOR THE FINAL PRODUCT
 * BUT WAS USED INITIALLY
 *
 ******************************************************************/

/*******************************************************************
 * LIBRARY INCLUDES
 ******************************************************************/
#include <math.h>
//#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#define bool int
#define true 1
#define false 0

/*******************************************************************
 * DEFINITIONS OF CONSTANTS
 ******************************************************************/
#define MAX_ENEMIES 20
#define WIDTH 20
#define HEIGHT 20
#define FOV 90
#define RAY_STEP 1.0
#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 240
#define RAY_SKIP 4
#define CLOCK_RATE 100000000

#define GAME_VIEW_WIDTH 200
#define GAME_VIEW_HEIGHT 120
#define GAME_VIEW_X_OFFSET 60
#define GAME_VIEW_Y_OFFSET 60
#define BORDER_COLOR 0x7BEF


/*******************************************************************
 * VARIABLE DEFINITIONS
 ******************************************************************/

 /*******************************************************************
 * AUDIO
 ******************************************************************/
int running[2048] = { 0,0,0,0,0,0,0,0,-10003,37511,-62519,55017,-27508,5002,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5002,-27508,55017,-62519,37511,-7502,-26258,67521,562671,680207,2501,-11253,-7502,47514,-100030,117536,-83776,32510,-5002,-1250,0,0,0,0,0,-1250,-1250,17505,-47514,-576425,-47514,17505,3751,-28759,57518,-60018,30009,2501,620189,40012,562671,120037,501403,110034,-53766,12504,0,0,-1250,-2501,10003,1250,602684,70021,-56267,17505,-647697,33760,-66270,65020,-36261,20006,-55017,110034,-125038,75023,-20006,0,0,0,2501,-8753,5002,677706,-102531,135041,-97530,37511,-6252,16255,-45014,-590180,-32510,680207,1207868,-578926,15005,543916,137542,-138792,100030,603934,-10003,-617688,-12504,-11253,35011,1252882,10003,5002,-1302897,35011,-1300396,20006,-35011,-1305397,-1131595,-202562,142543,-33760,-727722,-1087831,1062824,150046,-73772,32510,-25008,26258,-672705,-598932,577676,742726,-791491,-473894,-116285,40012,-16255,63769,546416,50015,-1272888,637694,-62519,115035,-106282,61269,-671454,40012,-81275,-1185361,-662702,-736474,-1131595,-58768,-92528,-510155,-41263,-2501,-51266,68771,-631442,-73772,46264,52516,523910,-567673,-1260384,-53766,35011,-43763,110034,-163800,-506404,-667703,-75023,-537664,-55017,635193,42513,-683958,-662702,-531412,-102531,2501,62519,-47514,17505,-1301646,-591430,-1369167,-1179109,-58768,2501,20006,-1337907,-492650,-200061,130040,-17505,-43763,72522,-91278,78774,-673955,-1291643,47514,-1374168,-1149100,-130040,755230,-128789,-1140347,532662,682708,1285391,6252,575175,87527,-41263,1297895,587679,720219,-700213,-598932,-21256,-12504,-613937,-21256,25008,1255382,2501,17505,-647697,-37511,-1194114,-81275,655200,-598932,-33760,637694,32510,-52516,72522,556419,712717,-65020,53766,-16255,-41263,745227,-152546,-458890,-207563,867764,1090332,742726,576425,-1212869,-685209,647697,-17505,37511,-17505,-15005,-1265385,-648948,-630192,11253,-61269,131290,-196310,190058,-115035,77524,-117536,145044,551418,1277889,40012,-1254132,-118786,775236,-67521,667703,-48765,41263,47514,512656,125038,-51266,-40012,75023,-676456,-667703,695212,-18756,585178,106282,-117536,765233,496401,747728,-17505,625190,-31260,-587679,-643946,-42513,25008,31260,541415,1455443,-227569,-422629,-117536,-73772,897773,977798,255078,-197560,0,337603,-2293198,-22381815,-26047931,-26483065,-34920632,-42958079,-44568569,-57875125,-30630577,-16870137,-35878424,-55175549,-47479458,-33641494,-16881390,1007807,-5841779,-49465061,-68294543,-56203365,-35149453,-21960436,-26031675,-24955100,-16418749,-27515878,-53289977,-39960917,-23429635,-10757026,-11438484,18428111,-3472307,4506372,-14850772,-40908707,-21203956,-13562879,-15823568,-9889261,-12998959,-23355861,-51765763,-87209051,-51066801,-17420304,5189080,-10266876,-35924690,-47158108,-2677065,-5314118,-7416008,-16733846,-5164072,-26067937,-9931774,13051475,20426220,28783764,33430178,33780286,13816708,40997483,56622243,57322454,52981131,49745149,34380469,15297158,35863420,6431958,-3962457,25927895,-1890576,4443853,13179013,6952117,-2627050,-7474776,-6165627,15467210,22674404,37126304,32982544,61156120,87924268,85348485,81957453,59150513,51915806,49297513,60848528,63724402,49582598,69976307,77571121,66257674,46316604,17402799,30276719,42640482,40097208,27745948,-5427903,-37270098,-21163944,8877703,-1426684,-21200205,-32916272,-17003927,-38933105,-68633397,-42514195,-31214505,-40334781,-57873870,-41775222,-32694955,-21321493,-54820444,-63105464,-22848206,-43259425,-26975713,-35374520,-29330181,-31447076,-372613,20901365,36873727,9272823,8842692,24624998,36691172,44433532,33465190,38004072,6784566,5186579,9452878,-40236001,-31154487,-8391305,-15517225,-28708742,-40356039,-60027027,-80933395,-71325468,-87611678,-81691122,-67324248,-36434843,-37102547,-50985523,-34237924,-18728203,10978343,19205848,-9162790,-40264761,-824001,4743945,20733812,13881726,12563826,-3799907,-2238181,-2712076,-5915552,-15723538,-32018498,-28740001,-15969863,-42097820,-55978295,-82545134,-58125200,-51450665,-71819368,-65691251,-37575192,-25357722,21641590,66182652,44748625,59343072,68928487,90675109,80742085,97524694,89879868,68543369,30644332,37716485,48752343,39001876,41125022,24292397,46961802,37316361,-4298809,4408843,-13130248,-9361600,22949488,2223177,16089899,23074526,4538882,-49918949,512656,50160275,87404118,74480181,87736716,74582712,57895128,49807668,56027062,15817316,33540212,65572465,49197481,31612125,37811513,35018164,35930941,56342155,100448086,66147643,21223962,57429987,77336047,66300190,63536845,60063291,64907264,66145139,65529954,76923425,63261764,94156169,68713421,39514532,33170101,57249931,88431925,103794104,106514932,79919335,74362644,52608521,39021882,3596095,-14093041,-43630785,-18105514,-46067778,-57202418,-59054234,-48010871,-64242063,-70895336,-62866642,-88003042,-98332437,-103962906,-92355619,-45925235,-63841939,-64158286,-48826115,-28544942,-54442827,-93757299,-65727515,-50625416,-27794712,-19657235,-35419534,-39244451,-30688094,-28953815,-21170195,-44408521,-75071609,-96539393,-66859107,-100175503,-124886774,-136292747,-131347493,-115592700,-102271143,-112382974,-145415529,-112227923,-108230452,-129369395,-148516468,-133868267,-117401996,-86745159,-47190620,-40692389,-32052259,-64861001,-52063351,-31812187,-57645053,-46634201,-15498469,-17647874,-13297799,-21331495,-3978712,11090877,-26339270,-54295282,-58795403,-29236402,-41101266,-53412512,-76070663,-70624003,-95487830,-77524858,-49890191,-80043124,-76752119,-67841909,-34936888,-46220325,-1182860,-341354,-21661596,-13402830,4883987,41505138,19863548,30906910,27420851,15589746,-8086212,31557110,-9551659,11403473,9327840,-21449032,-24640002,5326622,24745036,-13400331,35583335,54224013,66415223,39482021,7469775,-20428721,19743512,25202674,1738029,-12049919,-24117343,-14763245,-2239432,18035492,13564130,63681892,88907070,43355704,65797535,20873856,26768150,74680240,28768760,9230311,-181305,1743031,-12963948,37421396,3498565,31382056,31179493,-13973005,40444815,-4816467,14449400,-70260143,-211314,-26092945,7637325,-28976322,-38490471,-42589217,-70193871,-72450813,-32686203,-34467996,-22545616,-35525818,-78478897,-99228960,-91200266,-73767463,-89192156,-83831781,-68379569,-47415690,-41366348,-21474040,-10171847,-61686284,-100323048,-88693254,-68469597,-70358926,-113499559,-115942808,-102259889,-41581414,44015903,-28862538,-47460704,-17156474,-45673905,-61602507,-40204741,-51928314,-77293536,-72689635,-24471201,-4472612,25080137,-44272230,-17045190,-47598244,-14020519,-66954137,-32216059,-108051655,-83056539,-20166140,-75668040,-11886119,5864286,4653917,-298841,-33835302,-96002983,-75568008,-75004088,-90159957,-83139061,-78580178,-1309149,-28966321,-12700117,-39759606,-3113448,-76438275,-44987447,-26718136,-46711721,-59918245,-38449207,-23727224,-23963547,-4949007,-7163431,-30653084,-48539780,-103841616,-77447333,-68182013,-40429811,-20786329,3331014,12588833,-6283163,-46787997,-6011830,-74017538,-22918228,-34102885,26850675,92790757,90975206,39982175,48332215,58625351,21909171,22921979,27365832,12133695,65014797,78658953,75858100,43525756,74500184,98427472,63234255,32399866,29726552,40299771,51120565,16917651,16720091,43443228,74587714,113917188,64272071,21914173,-11626040,-3642359,77843704,86908964,65607475,54664144,142065753,110005996,125645755,102986360,103776604,74582712,-6815825,58357771,43643288,-32062263,-11811096,-21767878,50227796,11033360,-47930847,-41560156,-28441159,13296549,27428351,-32982544,-56359660,-94056137,-33800292,-3193472,-5251599,-43368207,-106815029,-83806765,-22993252,-27273303,-43678298,-50934258,-54684152,-32093522,-53620077,-59989519,-53477534,-14201824,10565718,-73821227,-128928010,-64620924,-25035123,-48103397,-50359085,21701608,-15891089,-2181914,-4605152,57725076,-43130634,13384075,-23604687,3125952,-17125215,-59338070,-16873889,55609433,21646590,47214376,57522513,67935685,142293332,75793078,23709719,55591928,37733990,87481633,37794008,88131838,2825860,-5674228,100428077,51023036,70326415,96809477,37608952,82097497,113171958,119576410,83282858,66967889,91375325,104606854,78053767,116110352,91795452,46616696,84490730,58347767,143346144,53948927,8092464,-29862843,8597618,-49522578,-18321829,50145268,62754107,10845802,63766917,37286354,44308494,-5169074,26515573,64744713,-20429971,45283791,78904026,59393083,-14246838,-65716262,68768439,28621215,-1071576,-6938363,-68005710,58180214,50340331,36003462,60158316,13564130,69001010,16835126,54834196,14511919,3401036,74872799,53626328,60140811,-15085844,-68219521,20308684,17182731,47929593,57747583,100210513,67250476,36666164,129877042,138894794,94298717,34372966,70081341,-35492057,15207131,31974736,53543806,68465849,44613583,61038588,16202434,51788270,39989678,56619740,47584487,48044631,-21110177,-14543178,-4901492,27936006,63166734,577676,4223786,21203956,-37779004,-69017266,-35263237,19120822,-51235599,-70681525,43223161,83535432,87059007,128661674,8937721,-22871965,-11397220,74050049,55021752,18910759,1370417,-138704734,-5657973,-19223353,90767636,4583896,-72687131,4911495,-14356872,-2998413,-33306392,-1039066,74910308,119954022,-44417276,-95587852,-1694266,123034963,30164184,-5839278,-58360270,-35518315,-19082061,36503616,111026307,148612753,174058009,164685142,19525946,72124461,41582663,88071813,106027284,54856703,-92731981,39106908,66130138,123300040,134038319,4641413,51985830,48402240,100155495,141225499,41797729,-2682067,111463944,54466583,81294756,21231465,48384735,106164825,51945819,-37255094,19798528,51108062,159033425,163049646,67147945,4393838,118323533,97407162,45036214,-61691286,-30046649,68645900,131007389,171387191,76720862,110408614,36018468,167646052,169886738,132965488,17187734,-17961719,36073484,61073598,-695212,16562543,27515878,-29986632,-128402843,15882336,105924753,60288356,-576425,-12261233,59853227,65922573,28759,-28358634,21078918,104584347,38331673,-89209665,778987,-106798768,-20672545,2570783,146999764,253289617,58202721,-12682611,11045864,-36744939,-31663391,157132843,142590920,162211890,2965903,76763373,-118464822,-123705166,-44514805,109798436,166768279,50242797,-148747795,-20173643,28198587,59660669,-55690706,46181562,18190540,-43463232,63554350,80249435,32469888,4766451,-1005306,55666950,100285540,15884837,103476507,68425837,7902406,49532582,-28498678,-69910035,-57720074,96496887,-116521734,12918934,215463100,115300109,-54062711,-18644427,-171576002,29876598,-125722031,16757602,-80577035,22946987,-68053222,-78408877,-170015524,-32507398,-67074173,41337589,-16023630,-12637599,179007011,16897645,-175473432,-193228839,-201738925,-139786310,-10838300,59470608,27228292,-101484647,50695436,-117954666,-255786635,-393544826,-444098973,-84380694,-64808486,32537409,-55013002,-185103871,-60824771,-217109849,-110318596,133898270,-163649830,-28805021,114382329,-22421827,42220355,-87310332,-279733926,-136689118,5461663,-6410702,35243231,-50830478,41012487,-50685431,-117527033,-15253394,-185895354,9445376,35608343,95183985,-189082573,-185615275,132192755,309154137,236144397,133873264,-496401,-5372886,-26049183,-5581699,-199306929,-224419588,26668120,27158270,-26080442,-223575575,-346124149,104979469,1325404,111749030,-53187447,-80515766,-31294529,-181201424,-127606353,-169626648,-273653318,32870009,12221222,50305316,24332409,96091761,192403595,36431093,-330460614,-173554100,32812492,246129951,132212753,100295544,238797705,3331014,108550557,-23112036,28581203,6424456,-120562960,-34050367,-137594395,-392748345,-275233805,-171711044,21296485,66395215,-19049551,-55039257,-107929116,102318656,-115900293,-158046875,-520781072,-351071911,-98567512,8755166,-117870895,-168445031,-288977988,-298419616,-148323910,-349470176,-464361412,-668010933,-687135509,-434517325,-322957087,-469793036,-507430761,-510339162,-56330901,-188341101,-314590798,-204702333,-242267521,-123996508,-24827561,-273280713,-207853294,-186400502,-94637571,-286500979,-235818046,-443725128,-231297936,-207249363,-84924610,-94963913,202451653,84045587,389673661,75252915,55419373,-135832613,102176108,187887204,261522123,138289604,53198700,-293561881,-366245250,-84090601,93125854,176773821,-234425130,-352859959,-66222664,-226235139,-16510027,23279590,325466598,-85999939,-106131064,-81592344,66087622,-48499769,-192931251,21889165,-147664960,-214827907,-59079239,-188543664,-191509572,-233396064,117795868,447371223,199350704,228237003,42500443,-286505995,-219006693,-99770377,-82851477,57307448,99405268,186254207,80319459,236006857,132367804,131207454,-115989071,76120679,150763411,-23888523,-112786841,-152941573,-67321750,-272312912,166863304,121652041,-293203028,-60908548,217548735,138857286,-293934506,-215264295,-414456190,-1462946,1780542,-15771052,4353826,348911239,178731930,180367426,-113407032,-309526742,-184803764,58737886,-340659984,-426161011,-256304296,184601201,-16978920,-101485906,-157381669,175923572,11568522,-108027899,-184149822,18032991,-194521732,25790352,-24713776,-343188244,-339670935,-298090766,-299533713,-264297980,-5011526,-164527603,-360087146,-280220325,-268282939,-238742697,-195045650,-11392219,-236076876,-507125658,-161717995,-273116907,-170211830,-280146548,-308220097,-533443700,-323974899,110941276,-207531940,-341831568,-409513464,-258713784,-358216586,-138299608,-39552043,-400366926,-301224217,-209142430,62176431,-109957235,-142542148,-354696758,-52042098,55261829,-166997107,-193876525,-214359017,-173305264,70008818,22594380,-135526270,101538416,-39824626,77118483,5661724,-287347490,-193401399,-56005804,-80154404,122197207,97257118,25877879,-35159457,-108840639,53763869,60003271,336942591,263290162,96201798,231528003,106089808,221269867,57242430,153504238,131770119,191105685,-168842661,-133500649,-29631522,-72830928,-24409932,50887994,31802183,-33945336,40089707,73367339,-62804123,21516553,-9496642,-180484958,-149407994,13981757,339115776,407916726,212099582,-15856078,56082075,116870583,-78698965,122587331,159591093,-2882128,-2186916,47261893,-10550712,26295508,156285092,77241022,104346774,-29862843,265195741,139329923,-36927494,-60754752,125635751,193816520,244584483,71714338,129944563,103709083,142465882,21631586,-16502526,37506422,199090614,275956527,185956618,-12552573,-141854445,121812089,108337990,134821057,144498998,334591868,31727161,32372356,-22570621,64497141,138404647,31504593,-62315226,-59037978,-16721342,2265690,114079734,72184482,76248215,-80579534,277762085,128981779,95559099,-8377551,-22578125,-46928041,-4964012,32277329,-15942354,76405764,152849046,53013642,-104443049,-74598967,-151786220,-37273849,149865629,80559530,-54036451,11260929,-111946586,61578751,-106376142,-38409195,38909347,60665973,84560750,-26119202,25462754,180900078,167828606,189697758,150050692,153826842,223880679,139782562,163982428,38904347,247322802,329942973,119646430,-68830958,163109662,205495076,240585753,224160757,261939761,259729078,274996242,256258023,185689033,190200408,133945782,225041029,125943353,255057656,156105036,130164636,68830958,136844169,134641001,177899171,98434968,131149937,212509705,199468236,159158463,177329000,86278768,225518673,215850716,142055759,252636933,298183292,290030820,222767822,71731843,93766054,80369470,64954777,44738620,103676571,65617479,214515327,174425617,99755376,19100816,77236020,76238216,33772783,115595199,15262147,123545118,27908499,-8737661,25825364,36468604,82827721,64652186,113236981,78994054,3343518,36313558,49267500,-13181513,89467247,40482326,111821548,153316686,93633511,-54005194,14314359,36478608,-15877334,7752361,51270613,60380888,77613632,15509723,53641335,131027398,105899748,49937708,111098825,17207740,85008382,22169251,-4037479,58160210,58685372,32845001,-537664,-5422901,-44572321,-6955868,-80325710,-87754216,-48372227,33880316,48284703,9372854,-45312549,-17902952,-81174715,-77708662,-97737261,-134802298,2370722,-66817846,-156727727,-107554002,-94121159,-105333325,-212599733,-174032984,-102573728,-100475590,-134457187,-62831633,-19273369,-84619516,-107181388,-136709127,-61660024,-75415466,-10260624,-7548549,-89434735,-110333597,-61692535,-74495182,-84728303,-66237671,-61927605,-88787039,-90755133,-73311071,-100773188,-24573732,-76807137,-121847099,-77811193,-32624933,51863291,2398230,12646351,9865504,30394254,104726885,67575578,69221078,94746348,119663939,74845290,88854560,75322934,65830046,25565285,66892867,100718170,81102197,6852086,62646574,21671598,51435663,31447076,23027010,35043172,20506244,912778,46124045,42910566,-4656418,13921740};
int shooter[770] = { -2560,-256,0,0,0,-563,-1536,205,0,0,102,-1229,-1126,205,0,0,0,0,0,-154,1638,4301,-461,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-51,410,-5478,-614,-51,410,1024,0,0,0,0,0,0,0,0,-461,4608,1638,-205,102,-717,-6246,-2099,-2509,358,-22579,-14438,-1126,102,0,0,0,0,0,307,-2048,-2355,922,-17971,-1075,102,-51,512,-5837,-666,102,0,0,0,0,0,0,-461,4403,1946,-2918,-2662,307,0,-102,614,102,0,0,0,0,0,-51,717,-15104,-1126,307,-6912,-2714,307,0,-410,4506,1434,-154,0,0,0,0,-51,410,1024,0,102,-717,-21658,-20838,-870,102,-154,2099,358,0,0,102,-717,-6554,512,-51,0,-461,4864,2355,-14950,-1331,2150,3994,1741,-410,102,-21504,-51,-2202,-1843,1741,-205,-614,7782,-20634,-205,717,-666,2355,1024,-1997,-2970,1946,4506,-358,-973,-19712,5632,1792,-7936,5427,410,-36813,-6349,563,-205,1946,-6451,-1229,0,1331,-1024,4096,-26214,-461,22118,-17510,-3021,819,-2611,19251,1229,16691,-2611,-22733,717,-102,1434,14950,819,-20326,-25139,-12390,-18022,27392,5018,3994,-11776,-1587,-22784,2662,3686,1894,4813,-3277,17715,-22374,3430,-1178,20275,-2355,-4710,614,15155,-2560,922,-3021,-31078,-27802,-32614,-26061,-11110,-2099,4966,-3840,4096,-52736,2560,-46029,-24422,24422,23706,-30874,-44544,-13414,-44032,7885,13773,101786,-52582,5274,-59699,-215398,-101581,-178330,99942,-17869,-62976,82022,-1792,-113203,4301,92058,78387,21146,206336,279040,158822,330445,-9062,76493,25498,-31027,314573,316928,78336,-142131,-87450,24218,-223693,-372941,-182784,-185702,-241562,-144845,-407142,-378266,-322816,233574,-137370,-146381,-110746,-604979,-209254,67430,-211866,305254,107520,-57088,157901,389120,7322,143872,236032,51712,-89293,398643,270746,221491,-198144,-92314,160666,-158822,133632,131738,106086,388301,110899,-42138,83046,172134,-222566,-61798,91238,-55450,110848,45773,324198,486195,29082,204595,-47821,927386,78950,-676557,332186,269670,50586,245043,431206,-146893,255488,600166,-360960,-97997,-108800,1318912,633754,-451942,469709,-177306,-732467,871219,2264781,-1278259,-274637,2032435,1363046,-1645978,1383629,2267750,-1113754,-674765,3494810,-238131,-946995,-456602,2929971,385485,-1450138,1957581,398541,-463104,2398925,871424,-226150,217856,57446,136448,-642355,-1645517,551526,1588736,1062502,-237722,-1351731,-2071450,-241818,286771,1681766,-960512,-1633280,663091,-473344,-619827,-1506560,-1951744,1687859,-386099,-2241792,3384934,-2600858,-5214106,20575949,12619776,11016294,7490918,15655834,15640064,9266842,14872064,19823206,10661427,15415296,18266522,12457933,-197478,10298778,16833536,11705805,13393306,19072307,15067546,11090330,21519360,15934054,10217984,2182195,7758131,13681459,11753933,13638246,11954688,8765440,16116326,8911565,3134464,12547584,14218547,1907661,7241626,9577062,5839821,-596070,4599296,5302886,1477171,7111424,14664294,5903974,3632538,10159872,11212493,-3045018,-3262720,-2478234,-2648474,2884813,-2250291,-41216,5232077,4333158,-4831795,2708019,4611226,-1448294,-1306573,-538573,-4250982,3869696,2328371,-29328998,4732058,6757683,-600064,8563046,-11854131,-1864294,13383066,-10258278,12246733,-4636826,-31409920,-4634214,14583603,-11765760,14696448,-26115533,1865728,-10968218,-17304320,-3374950,-11389850,-19557325,576256,-8642304,-14019789,3673907,-21824819,-8532480,-23761664,18944410,-11631309,-30521498,-2768538,-82845901,-7237171,-45056,-29127117,-3487590,-52063027,28997530,63582618,16174490,25701376,41991066,40149299,77699686,-5712230,82069606,-135602176,-89608806,56296243,-71842304,-342444902,-61215949,22629325,51990118,382515507,-195526195,19909530,-65854157,135947469,96877978,-432154982,-85547315,-365521306,-38178355,-453018,-171253402,-629717811,28624230,193133466,105584640,-272600320,13164442,322290534,42379981,-51013837,-124554342,-1556232602,-49862502,114955674,-265106995,-132381645,120169318,-139402752,192967219,26386790,0,-45813146,-82413363,-1714700902,-1696070861,-536447181,-1700971418,1412263526,77125171,-38095258,-151637504,49001267,58401741,-15032730,134460723,-35122176,-1003077427,-1449210880,-1544365056,1278218547,1365081702,1415397581,1381739110,1544314061,1020689920,1321858765,1317479936,-1399757824,-1384479949,736968192,458348544,1454875955,1387073331,-8952883,-129672192,116079872,969584333,-22685798,1546629530,1307760640,-298539213,-1172223795,1593036595,1355149107,1410692096,-256125542,-448539750,25038131,-286681242,1397897011,1430924902,1688759501,-550791885,-66412339,266939597,-102289408,-1646736589,-132027853,1568693658,1703572890,1453992346,24928256,-15706778,-118364621,-266478541,-109147136,32040653,471665971,21533082,82605722,41651917,1717986918,115068365,-1238386278,-214074778,-225675315,-1492269056,-1174417101,-1311872000,-289423462,-448372378,331189402,-59704986,-557254042,-96882483,736358,-314143027,253233869,109493043,-1436570,-146418483,-1281209754,-1262691123,-97943245,-600499354,-11391078,-244508877,-94666445,-10648576,487084954,-73064755,-118320998,467784397,872391270,-1509464269,-214125875,-1699450880,1375392870,326883738,1144226611,1616015565,1519100211,1273844122,-296412365,428258611,-43800576,-1427120230,-124672461,331179008,1699520512,1062039859,293665126,181183130,-157959578,1444616602,305630618,-243096781,1438139187,1325212877,-391715738,-102076672,17896141,-145186202,-181618227,-1711625830,199946701,-8551629,284638464,105597235,-66416384,297262029,53477939,-34905344,-1697772749,-1368116224,-127222630,-260069427,-8834816,102590822,-160843674,308962304,102861,-1184432947,-490998477,-1717986918,-1576426394,-16296755,-1642658714,-1135663514,-1367580058,-1255101850,-1717986918,-27632384,240995021,-30161152,1717986918,32757453,-238516429,-913816986,-107740160,12983040,-90199245,-724444211,-88308582,-198022298,-1204893286,-246050509,-1014366413,1470526874,83854643,-1093497446,-682862797,-408584243,-176592794,-109472051,-580833536,59678515,-451118490,595560448,-1162193715,-1390489190,-1567225037,-675680717,-205963878,276421376};

/*******************************************************************
 * INTS
 ******************************************************************/
int num_enemies = 0;
int dead = 0;
int any_key_pressed = false;

/*******************************************************************
 * FLOATS
 ******************************************************************/
float player_x = 6.0f;
float player_y = 9.0f;
float player_angle = 0.0f;
float dir_x, dir_y;          
float plane_x, plane_y;      
float tan_fov;  

/*******************************************************************
 * SHORT INTS
 ******************************************************************/
short int current_buffer;
short int colour = 0xffff;
short int start = 0;
short int click = 0;
short int time = 99;
short int score1 = 0;
short int buffer1[240][512]; //240 rows, 512 (320 + padding) columns
short int buffer2[240][512];

/*******************************************************************
 * VOLATILE INTS
 ******************************************************************/
volatile int pixel_buffer_start; //global variable
volatile int counter = 0;
volatile int digit1 = 0;  
volatile int digit10 = 0;    
volatile int digit100 = 0;    
volatile int total_time = 99; //total time left
volatile int KEY_dir = 1;  

/*******************************************************************
 * CHARACTER PRINT ARRAYS
 ******************************************************************/
char hex_disp_nums[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x67}; // 7-segment codes for digits 0, 1, ..., 9
char simulated_keys[] = {'W', 'A', 'S', 'D'};
char grid[WIDTH][HEIGHT] = { //x->
    {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},  // y = 0
    {'#', '.', '.', '.', '#', '#', '#', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '#'},  // y = 1
    {'#', '.', 'X', '#', '#', '#', '.', '.', 'X', '.', '#', '.', '#', '#', '#', '#', '.', '.', 'X', '#'},  // y = 2
    {'#', '.', '.', '.', '.', '.', '.', '#', '.', '.', '#', '.', '.', '.', '#', '#', '#', '#', '.', '#'},  // y = 3
    {'#', '.', '#', '#', '#', '.', 'X', '.', '.', 'X', '.', '.', '#', '#', '#', '.', '.', '.', '.', '#'},  // y = 4
    {'#', '.', '.', '.', '.', '#', '.', '.', '#', '.', '#', '#', '#', '#', '.', '.', '#', '#', '#', '#'},  // y = 5
    {'#', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '#', '.', '#', '#', '#'},  // y = 6
    {'#', '.', 'X', '#', '.', '.', '#', '#', '#', '.', '#', '.', '.', 'X', '#', '.', '.', '.', '.', '#'},  // y = 7
    {'#', '.', '.', '.', '.', '#', '#', '.', '.', '#', '.', '#', '.', '.', '#', '.', '#', 'X', '.', '#'},  // y = 8
    {'#', '.', '.', '#', '#', '.', '.', '.', '#', '#', '.', 'X', '.', '#', '.', '.', '.', '.', '#'},  // y = 9
    {'#', '.', '#', '#', '#', '.', '.', '.', '#', '#', '#', '#', '.', '.', 'X', '#', '#', '#', '#', '#'},  // y = 10
    {'#', 'X', '.', '.', '.', '#', '.', 'X', '.', '.', '#', '#', '.', '.', '.', '#', '.', '.', '.', '#'},  // y = 11
    {'#', '.', '.', 'X', '.', '.', '.', '.', '#', '#', '.', '.', '.', '#', '.', '.', '#', 'X', '.', '#'},  // y = 12
    {'#', '.', '.', '.', '.', '#', 'X', '.', 'X', '.', '#', '#', '.', '#', '#', '#', '.', '.', '.', '#'},  // y = 13
    {'#', '.', '#', '#', '.', '#', '#', '.', '.', '.', '#', '.', '.', '#', '.', '#', '.', '#', '#', '#'},  // y = 14
    {'#', '.', '.', '.', '#', '.', '.', '#', '.', '#', '#', '#', '.', '.', '.', '.', '.', '.', '.', '#'},  // y = 15
    {'#', '.', 'X', '.', '#', '.', '.', '.', '#', '#', '#', '.', '#', '.', '.', '#', '.', 'X', '.', '#'},  // y = 16
    {'#', 'X', '.', '#', '#', '#', '.', 'X', '.', '.', 'X', '#', '.', '#', '.', '.', '.', '.', '.', '#'},  // y = 17
    {'#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'X', '#'},  // y = 18
    {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'}   // y = 19
};
static const int digit_font[10][7] = {
    {0x1F, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1F}, // 0
    {0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E}, // 1
    {0x1F, 0x01, 0x01, 0x1F, 0x10, 0x10, 0x1F}, // 2
    {0x1F, 0x01, 0x01, 0x0F, 0x01, 0x01, 0x1F}, // 3
    {0x11, 0x11, 0x11, 0x1F, 0x01, 0x01, 0x01}, // 4
    {0x1F, 0x10, 0x10, 0x1F, 0x01, 0x01, 0x1F}, // 5
    {0x1F, 0x10, 0x10, 0x1F, 0x11, 0x11, 0x1F}, // 6
    {0x1F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}, // 7
    {0x1F, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x1F}, // 8
    {0x1F, 0x11, 0x11, 0x1F, 0x01, 0x01, 0x1F}  // 9
};
static const int char_font[59][7] = {
    // Space (index 0)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// A (1)
    {0x04, 0x0A, 0x11, 0x1F, 0x11, 0x11, 0x11}, // B (2)
    {0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E}, // C (3)
    {0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E}, // D (4)
    {0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C}, // E (5)
    {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F}, // F (6)
    {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10}, // G (7)
    {0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F}, // H (8)
    {0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11}, // I (9)
    {0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E}, // J (10)
    {0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C}, // K (11)
    {0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11}, // L (12)
    {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F}, // M (13)
    {0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11}, // N (14)
    {0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x11}, // O (15)
    {0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E}, // P (16)
    {0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10}, // Q (17)
    {0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0D}, // R (18)
    {0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11}, // S (19)
    {0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E}, // T (20)
    {0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04}, // U (21)
    {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E}, // V (22)
    {0x11, 0x11, 0x11, 0x11, 0x0A, 0x0A, 0x04}, // W (23)
    {0x11, 0x11, 0x11, 0x15, 0x15, 0x1B, 0x11}, // X (24)
    {0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11}, // Y (25)
    {0x11, 0x11, 0x0A, 0x04, 0x04, 0x04, 0x04}, // Z (26)
    {0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F},
};

/*******************************************************************
 * DOUBLES
 ******************************************************************/
double score = 0;

/*******************************************************************
 * HARDWARE DEFINITIONS AND POINTERS
 ******************************************************************/
volatile int *pixel_ctrl_ptr = (int *)0xFF203020; //display
volatile int * PS2k_ptr = (int *) 0xFF200100; //keyboard
volatile int * PS2m_ptr = (int *) 0xFF200108; //mouse
volatile int *ledr_ptr = (int *) 0xff200000; //leds
volatile int *hex3_0_ptr = (int *) 0xff200020; //hex 0 to 3
volatile int *hex5_4_ptr = (int *) 0xff200030; //hex 4 to 5

/*******************************************************************
 * STRUCT DEFINITIONS
 ******************************************************************/
typedef struct{
    int map_x;
    int map_y;
    int side;
    float perp_dist;
    int hit;
char hit_type;
float ray_dir_x;
    float ray_dir_y;
} ray_result;

struct audio_t{
      volatile unsigned int control;
      volatile unsigned char rarc;
      volatile unsigned char ralc;
      volatile unsigned char wsrc;
      volatile unsigned char wslc;
      volatile unsigned int ldata;
      volatile unsigned int rdata;
};

struct PIT_t{
      volatile unsigned int DR;
      volatile unsigned int DIR;
      volatile unsigned int MASK;
      volatile unsigned int EDGE;
};

typedef struct {
    short int hp;
    short int x;
    short int y;
    short int speed;
}Enemy;

/*******************************************************************
 * STRUCT VARIABLES/ARRAYS
 ******************************************************************/
Enemy enemies[MAX_ENEMIES];
struct PIT_t *const buttonp = ((struct PIT_t *) 0xFF200050);
struct audio_t *const audiop = ((struct audio_t *)0xff203040);

/*******************************************************************
 * FUNCTION DECLARATIONS
 ******************************************************************/
//TITLE + ENDING SCREEN DRAWING
void plot_char(int x, int y, char c);
void clear_char(void);
void title_screen(void);
void title_screen2(void);
void title_screen3(void);
void game_win_screen();
void game_win_screen2();
void game_loss_screen();
void game_loss_screen1();
void game_loss_screen2();

//AUDIO PLAYER
void audioplayer(const int *audio, int sample_number);

//GRAPHICS
void plot_pixel(short int x, short int y, short int line_color);
void clear_screen();
void draw_mouse(short int colour);
void draw_number(int start_x, int start_y, int number, short color);
void draw_score1board(short int score1, short int time);
void draw_vertical_line(short int x, short int y_start, short int y_end, short color);
void draw_text(int x, int y, const char *text, short color);
ray_result cast_ray_dda(float ray_dir_x, float ray_dir_y, float player_x, float player_y);
short int calculate_wall_colour(float distance, float ray_dir_x, float ray_dir_y, short int side, char hit_type);
void wait_for_vsync();

//GAME LOGIC
void move_player(char direction);
void move_player_with_keyboard(bool* movement);
int check_collision(float new_x, float new_y);
void initialize_enemies();
void mouse_input_check();
int game_end_check();
void hex_disp();
void draw_digit(int start_x, int start_y, int digit, short color, int scale);
void move_enemies();
int any_key_pressed_check();

/*******************************************************************
 * INTERRUPT RELATED FUNCTIONS
 ******************************************************************/
static void handler(void) __attribute__((interrupt("machine")));void keyb_ISR(void);
void set_ps2(void);
void mouse_ISR(void);
void itimer_ISR(void);
void set_itimer(void);
void interrupt_init();

/*******************************************************************
 * MAIN FUNCTION
 ******************************************************************/
int main(void){
//INTERRUPTS SET, ENEMIES INTIALIZED
set_itimer();
set_ps2();
    interrupt_init();
initialize_enemies();

// ZEROING HEX DISPLAYS
*hex3_0_ptr = ((hex_disp_nums[0] << 16) | (hex_disp_nums[0] << 8)) | hex_disp_nums[0];
*hex5_4_ptr = (hex_disp_nums[0] << 8) | hex_disp_nums[0];

//INTIALIZE GAME
    dir_x = cos(player_angle);
    dir_y = sin(player_angle);
    tan_fov = tan(FOV * M_PI / 360.0f);

    volatile int *pixel_ctrl_ptr = (int *)0xFF203020;

    *(pixel_ctrl_ptr + 1) = (int) &buffer1;
    wait_for_vsync();
    pixel_buffer_start = *pixel_ctrl_ptr;
    clear_screen();
    title_screen();
    title_screen2();
    title_screen3();


    *(pixel_ctrl_ptr + 1) = (int) &buffer2;
    wait_for_vsync();
    pixel_buffer_start = *(pixel_ctrl_ptr + 1);
    clear_screen();
    title_screen();
    title_screen2();
    title_screen3();


buttonp->EDGE = 1;
    float inv_screen_width = 1.0f / SCREEN_WIDTH;

bool movement = false;

*(PS2m_ptr) = 0xf4; // enables data reading for mouse

int game_finished = 0;

static int enemy_move_timer = 0;

//GAME LOOP
    while (1){

int one_draw = 0;

volatile int *PS2k_ptr = (int *)0xFF200100;

//TITLE SCREEN, WAITING FOR USER INPUT

int ps2kdata;

do {
ps2kdata = *PS2k_ptr;
} while (ps2kdata & 0x8000);

if (start == 0){
while (!any_key_pressed){
any_key_pressed = any_key_pressed_check();
}
}

clear_char();

        //BEGIN GAME
if (start == 0){
            // Draw scoreboard once on both buffers
for (int i = 0; i < 2; i++){
*(pixel_ctrl_ptr + 1) = (i == 0) ? (int)&buffer1 : (int)&buffer2;  
wait_for_vsync();
pixel_buffer_start = *pixel_ctrl_ptr;
clear_screen();
draw_score1board((short)score, time);
}
        }

//GAME LOGIC
while (!game_finished){

if (++enemy_move_timer >= 100){  // Move every 15
move_enemies();
enemy_move_timer = 0;
}

draw_score1board((short)score, time);

if (start == 0){
start++;
}

if (current_buffer == 0){
*(pixel_ctrl_ptr + 1) = (int)buffer2;
current_buffer = 1;
}
else{
*(pixel_ctrl_ptr + 1) = (int)buffer1;
current_buffer = 0;
}

pixel_buffer_start = *(pixel_ctrl_ptr + 1);


plane_x = dir_y * tan_fov;
plane_y = -dir_x * tan_fov;

for (short int x = GAME_VIEW_X_OFFSET; x < GAME_VIEW_X_OFFSET + GAME_VIEW_WIDTH; x += RAY_SKIP){
float camera_x = 2 * x * inv_screen_width - 1;
float ray_dir_x = dir_x + plane_x * camera_x;
float ray_dir_y = dir_y + plane_y * camera_x;

//dda res
ray_result ray = cast_ray_dda(ray_dir_x, ray_dir_y, player_x, player_y);

if (ray.hit){
short int line_height = (int)(GAME_VIEW_HEIGHT / ray.perp_dist);
short int draw_start = (-line_height / 2) + (GAME_VIEW_HEIGHT / 2) + GAME_VIEW_Y_OFFSET;
short int draw_end = (line_height / 2) + (GAME_VIEW_HEIGHT / 2) + GAME_VIEW_Y_OFFSET;

//adjust for enemies
if (ray.hit_type == 'X'){
short int enemy_height = line_height * 0.6;
draw_start = (-enemy_height / 2) + SCREEN_HEIGHT / 2;
draw_end = (enemy_height / 2) + SCREEN_HEIGHT / 2;

draw_start += line_height * 0.1;
draw_end += line_height * 0.1;
}

draw_start = (draw_start < GAME_VIEW_Y_OFFSET) ? GAME_VIEW_Y_OFFSET : draw_start;
draw_end = (draw_end >= GAME_VIEW_Y_OFFSET + GAME_VIEW_HEIGHT) ? GAME_VIEW_Y_OFFSET + GAME_VIEW_HEIGHT - 1 : draw_end;

short int wall_colour = calculate_wall_colour(ray.perp_dist,
ray.ray_dir_x, ray.ray_dir_y,
ray.side, ray.hit_type);

for (int i = 0; i < RAY_SKIP; i++){
if (x+i >= SCREEN_WIDTH) break;

draw_vertical_line(x+i, 0, draw_start-1, 0x0);

draw_vertical_line(x+i, draw_start, draw_end, wall_colour);

if (ray.hit_type == 'X'){
short int head_start = draw_start + (draw_end - draw_start) * 0.2;
short int head_end = draw_start + (draw_end - draw_start) * 0.4;
draw_vertical_line(x+i, head_start, head_end, 0xF800); //red strip on ememy head
}

draw_vertical_line(x+i, draw_end+1, SCREEN_HEIGHT-1, 0x0);
}
}
}

draw_mouse(colour);

wait_for_vsync();

move_player_with_keyboard(&movement);

game_finished = game_end_check();
}

//GAME FINISHED, CHECK CONDITION

//WINNER
if (game_finished == 1){
clear_screen();
game_win_screen();
game_win_screen2();

//add reset logic
}
//LOSS, EITHER DUE TO ENEMY HIT OR NO TIME
        else if(game_finished == 3){
            clear_screen();
            game_loss_screen();
game_loss_screen2();
        }
else{
clear_screen();
game_loss_screen();
game_loss_screen2();

//add reset logic
}

printf("game has finished! congrats!\n");
break; // remove this to keep game running

    }

    return 0;
}

/*******************************************************************
 * FUNCTIONS
 ******************************************************************/

/************************************************
 * TITLE AND ENDING SCREEN FUNCTIONS
 ***********************************************/
void plot_char(int x, int y, char c){
volatile char *character_buffer = (char *)(0x09000000 + (y<<7) + x);
*character_buffer = c;
}
void clear_char(void){
int x,y;
for(x = 0; x < 80; x++){
for(y = 0; y < 60; y++){
plot_char(x,y,0);
}
}
}
void title_screen(void){
char *press = "!! 3D FPS GAME !!";
int x = 30;
while(*press){
plot_char(x, 15, *press);
x++;
press++;
}

wait_for_vsync();
}
void title_screen2(void){

char *press = "MADE BY MARK PIRNER AND ARYAN BILLAH";
int x = 21;
while(*press){
plot_char(x, 30, *press);
x++;
press++;
}

wait_for_vsync();
}
void title_screen3(void){

char *press = "+++ ! PRESS ANY KEY TO START ! +++";
int x = 22;
while(*press){
plot_char(x, 40, *press);
x++;
press++;
}

wait_for_vsync();
}
void game_win_screen(){
char *press = "WINNER WINNER!!";
int x = 30;
while(*press){
plot_char(x, 15, *press);
x++;
press++;
}

wait_for_vsync();
}
void game_win_screen2(){
char *press = "RESTART TO PLAY AGAIN!";
int x = 27;
while(*press){
plot_char(x, 30, *press);
x++;
press++;
}

wait_for_vsync();
}
void game_loss_screen(){
char *press = "LOSER LOSER!!";
int x = 30;
while(*press){
plot_char(x, 15, *press);
x++;
press++;
}

wait_for_vsync();
}
void game_loss_screen1(){
char *press = "YOU DIED TO ENEMY!!";
int x = 30;
while(*press){
plot_char(x, 15, *press);
x++;
press++;
}

wait_for_vsync();
}
void game_loss_screen2(){
char *press = "RESTART TO PLAY AGAIN!";
int x = 27;
while(*press){
plot_char(x, 30, *press);
x++;
press++;
}

wait_for_vsync();
}

/************************************************
 * AUDIO FUNCTION
 ***********************************************/
void audioplayer(const int *audio, int sample_number){
audiop->control = 0x8; //clear fifo
audiop->control = 0x0; //resume output conversion

for (int x = 0; x < sample_number; x++){
while (audiop->wsrc == 0);

audiop->ldata = audio[x];
audiop->rdata = audio[x];
}

}

/************************************************
 * GRAPHICS RELATED FUNCTIONS
 ***********************************************/
void plot_pixel(short int x, short int y, short int line_color){
    volatile short int *one_pixel_address = (volatile short int *)(pixel_buffer_start + (y << 10) + (x << 1));
    *one_pixel_address = line_color;
}
void clear_screen(){
    for (short int i = 0; i < SCREEN_WIDTH; i++){
        for (short int j = 0; j < SCREEN_HEIGHT; j++){
            plot_pixel(i, j, 0);  
        }
    }
}
void draw_mouse(short int colour){
for(int i = 157; i < 163; i++){
for(int j = 117 ; j < 123; j++){
plot_pixel(i, j, colour);
}
}

}
void draw_number(int start_x, int start_y, int number, short color){
    int scale = 4;  
    int tens = (number / 10) % 10;
    int units = number % 10;
   
    draw_digit(start_x, start_y, tens, color, scale);
    draw_digit(start_x + (5 * scale) + scale, start_y, units, color, scale);
}
void draw_score1board(short int score1, short int time){
short int white = 0xFFFF;
    short int red = 0xF800;  
    int scale = 4;
    int digit_width = 5 * scale;
    int digit_height = 7 * scale;
    int spacing = scale;
   
if (start == 0){
for (int y = 0; y < 60; y++){
volatile short int *addr = (short int*)pixel_buffer_start + (y << 9);
for (int x = 60; x < 260; x++){
addr[x] = white;
}
}

draw_text(78, 6, "score", 0x0000);
        draw_text(189, 6, "Time", 0x0000);
}

if (start == 1){
for (int y = 25; y < 25 + digit_height; y++){  
        volatile short int *addr = (short int*)pixel_buffer_start + (y << 9);
       
for (int x = 85; x < 85 + (digit_width * 2) + spacing; x++){  
addr[x] = white;
}

for (int x = 190; x < 190 + (digit_width * 2) + spacing; x++){  
addr[x] = white;
}
}
}
   
    draw_number(85, 25, score1, red);  
    draw_number(190, 25, time, red);    
}
void draw_vertical_line(short int x, short int y_start, short int y_end, short color){
    if (x < GAME_VIEW_X_OFFSET || x >= GAME_VIEW_X_OFFSET + GAME_VIEW_WIDTH){
        return;
    }

    y_start = (y_start < GAME_VIEW_Y_OFFSET) ? GAME_VIEW_Y_OFFSET : y_start;
    y_end = (y_end >= GAME_VIEW_Y_OFFSET + GAME_VIEW_HEIGHT) ? GAME_VIEW_Y_OFFSET + GAME_VIEW_HEIGHT - 1 : y_end;

    volatile short int *addr = (short int*)pixel_buffer_start + (y_start << 9) + x;

    for(short int y = y_start; y <= y_end; y++){
        *addr = color;
        addr += 512;
    }
}

void draw_text(int x, int y, const char *text, short color){
    int char_index = 0;
    int scale = 2;
    for (int i = 0; text[i] != '\0'; i++){
        char c = text[i];
       
        if (c >= 'A' && c <= 'Z'){
char_index = c - 'A' + 1;
}
        else if (c >= 'a' && c <= 'z'){
char_index = c - 'a' + 1;
}
        else if (c == ' '){
char_index = 0;
}
        else{
continue;
}

        for (int row = 0; row < 7; row++){
            for (int col = 0; col < 5; col++){
                if (char_font[char_index][row] & (0x10 >> col)){
for (int dy = 0; dy < scale; dy++){
for (int dx = 0; dx < scale; dx++){
plot_pixel(x + ((i * 6) + col) * scale + dx, y + row * scale, color);
}
                }
                }
            }
        }
    }
}
ray_result cast_ray_dda(float ray_dir_x, float ray_dir_y, float player_x, float player_y){
    ray_result result;
    result.hit = 0;
result.hit_type = '.';
   
    result.map_x = (int)player_x;
    result.map_y = (int)player_y;
   
    float delta_dist_x = (ray_dir_x == 0) ? 1e30f : fabs(1 / ray_dir_x);
    float delta_dist_y = (ray_dir_y == 0) ? 1e30f : fabs(1 / ray_dir_y);

    int step_x = (ray_dir_x < 0) ? -1 : 1;
    float side_dist_x = (ray_dir_x < 0) ? (player_x - result.map_x) * delta_dist_x : (result.map_x + 1.0f - player_x) * delta_dist_x;
   
    int step_y = (ray_dir_y < 0) ? -1 : 1;
    float side_dist_y = (ray_dir_y < 0) ? (player_y - result.map_y) * delta_dist_y : (result.map_y + 1.0f - player_y) * delta_dist_y;

    while (!result.hit){

        if (side_dist_x < side_dist_y){
            side_dist_x += delta_dist_x;
            result.map_x += step_x;
            result.side = 0;
        }
else{
            side_dist_y += delta_dist_y;
            result.map_y += step_y;
            result.side = 1;
        }

        if (result.map_x < 0 || result.map_x >= WIDTH ||
            result.map_y < 0 || result.map_y >= HEIGHT){
            result.hit = 0;
            return result;
        }

        char cell = grid[result.map_x][result.map_y];
        if (cell == '#' || cell == 'X'){
            result.hit = 1;
            result.hit_type = cell;
        }
    }

    if (result.side == 0){
        result.perp_dist = (result.map_x - player_x + (1 - step_x) / 2) / ray_dir_x;
    }
else{
        result.perp_dist = (result.map_y - player_y + (1 - step_y) / 2) / ray_dir_y;
    }

result.ray_dir_x = ray_dir_x;
    result.ray_dir_y = ray_dir_y;

    return result;
}
short int calculate_wall_colour(float distance, float ray_dir_x, float ray_dir_y, short int side, char hit_type){
    short int r_base, g_base, b_base;
    if (hit_type == 'X'){
        float pulse = 0.5f + 0.5f * sin(counter * 0.1f);
        r_base = 31 * pulse;
        g_base = 10 * (1 - pulse);
        b_base = 0;
       
        if ((int)(distance * 20) % 4 < 2){
            r_base *= 0.8f;
        }
    }
else{
        r_base = 0; g_base = 0; b_base = 31;
    }  
   
//scale by distance
    float distance_factor = 1.0f / (1.0f + distance * 0.1f);

    if (distance_factor > 1.0f){
distance_factor = 1.0f;
}
    if (distance_factor < 0.3f){
distance_factor = 0.3f;
}
   
//scale by angle
    float angle = atan2(ray_dir_y, ray_dir_x);

    float angle_factor = (angle + M_PI) / (2.0f * M_PI);
   
//use distance and angle factor to generate depth
    float colour_mix = distance_factor * 0.8f + angle_factor * 0.2f;
   
//scale further if it hits a wall's side or not
if (side == 1){
colour_mix *= 0.825f;
}
   
//scale colour compoenents
    int r = (int)(r_base * colour_mix);
    int g = (int)(g_base * colour_mix);
    int b = (int)(b_base * colour_mix);

//shift to desired format 5r, 6g, 5b
    return ((r & 0x1F) << 11) | ((g & 0x3F) << 5) | (b & 0x1F);
}
void wait_for_vsync(){
volatile int *status_register = (volatile int *)0xFF20302C;
*pixel_ctrl_ptr = 1;
while ((*status_register & 0x01) == 1);
}

/************************************************
 * GAME LOGIC FUNCTIONS
 ***********************************************/
void initialize_enemies(){
    for (int i = 0; i < WIDTH; i++){
        for (int j = 0; j < HEIGHT; j++){
            if (grid[i][j] == 'X') {
                if (num_enemies < MAX_ENEMIES){
                    enemies[num_enemies].hp = 5;
                    enemies[num_enemies].x = i;
                    enemies[num_enemies].y = j;
                    enemies[num_enemies].speed = 1;
                    num_enemies++;
                }
            }
        }
    }
}
void mouse_input_check(){
int ps2mdata = *(PS2m_ptr); // read the Data register in the PS/2 port

int rvalid = (ps2mdata & 0x8000); // gets bit 15, to see if read data is valid

unsigned int mousepressed = (ps2mdata); // gets the pressed value and holds it

//printf("%d\n", mousepressed);

if (rvalid != 0 && mousepressed == 163849){

printf("mouse pressed *******\n");

}

ps2mdata = 0;
}
int check_collision(float new_x, float new_y){
    int map_x = (int)new_x;
    int map_y = (int)new_y;

    if (map_x >= 0 && map_x < WIDTH && map_y >= 0 && map_y < HEIGHT){
        if (grid[map_x][map_y] == '#'){
            return 0;
        }
if (grid[map_x][map_y] == 'X') {
            dead = 1;
            return 1;
        }
    }
    return 1; //can move
}
void move_player(char direction){
    float move_step = 0.05f;
    float new_x = player_x;
    float new_y = player_y;

    switch (direction){
        case 'W':
            new_x = player_x + dir_x * move_step;
            new_y = player_y + dir_y * move_step;
            break;
        case 'S':
            new_x = player_x - dir_x * move_step;
            new_y = player_y - dir_y * move_step;
            break;
        case 'D':
            player_angle -= M_PI / 36.0f;
            dir_x = cos(player_angle);
            dir_y = sin(player_angle);
            return;
        case 'A':
            player_angle += M_PI / 36.0f;
            dir_x = cos(player_angle);
            dir_y = sin(player_angle);
            return;
    }
    if (check_collision(new_x, new_y)){
        player_x = new_x;
        player_y = new_y;
    }
}
void move_player_with_keyboard(bool* movement){
int ps2kdata = *(PS2k_ptr); //read the Data register in the PS/2 port

int rvalid = (ps2kdata & 0x8000); //gets bit 15, to see if read data is valid

unsigned char keypressed = (ps2kdata & 0xff); //gets the pressed value and holds it
if (rvalid != 0){
if (keypressed == 0x29){ //space to shoot
if (click){
colour = 0xffff;
click = 0;
}
else{
colour = 0xfd4c;
click = 1;
}

draw_mouse(colour);
audioplayer(shooter, 770);

ray_result shot_ray = cast_ray_dda(dir_x, dir_y, player_x, player_y);
if (shot_ray.hit && shot_ray.hit_type == 'X'){
for (int i = 0; i < num_enemies; i++) {
if (enemies[i].x == shot_ray.map_x && enemies[i].y == shot_ray.map_y){
grid[enemies[i].x][enemies[i].y] = '.';
enemies[i] = enemies[num_enemies - 1];
num_enemies--;
score += 1;
break;
}
}
}


}
else{
if (keypressed == 0x1D){ //up
move_player('W');
}

else if (keypressed == 0x1B){ //down
move_player('S');
}

else if (keypressed == 0x1C){ //turn left
move_player('A');
}

else if (keypressed == 0x23){ //turn right
move_player('D');
}

*movement = true;

audioplayer(running, 2048);
}

}
//else { *movement = false; }
}
int game_end_check(){
if (score >= 10){
return 1;
}
else if (total_time <= 0){
return 2;
}
else if (dead == 1){
return 3;
}
else {
return 0;
}
}
void hex_disp(){

int time = (hex_disp_nums[digit100] << 16) | (hex_disp_nums[digit10] << 8);

    *hex3_0_ptr = time | hex_disp_nums[digit1]; // Display in decimal

int int_score = (int)score;

int ones = int_score % 10;

int tens = (int)(score / 10);

*hex5_4_ptr = (hex_disp_nums[tens] << 8) | hex_disp_nums[ones];
}
void draw_digit(int start_x, int start_y, int digit, short color, int scale){
    if (digit < 0 || digit > 9) return;
    const int *rows = digit_font[digit];
   
    for (int y = 0; y < 7; y++){
        int row = rows[y];
        for (int x = 0; x < 5; x++){
            if (row & (1 << (4 - x))){
                for (int dy = 0; dy < scale; dy++){
                    for (int dx = 0; dx < scale; dx++){
                        plot_pixel(start_x + x * scale + dx, start_y + y * scale + dy, color);
                    }
                }
            }
        }
    }
}
void move_enemies(){
    int directions_x[4] = {0, 0, -1, 1};
    int directions_y[4] = {-1, 1, 0, 0};

    for (int i = 0; i < num_enemies; i++){
        int ex = enemies[i].x;
        int ey = enemies[i].y;
       
        int dx = (int)player_x - ex;
        int dy = (int)player_y - ey;
       
        int move_x = (dx != 0) ? ((dx > 0) ? 1 : -1) : 0;
        int move_y = (dy != 0) ? ((dy > 0) ? 1 : -1) : 0;

        int new_x = ex + move_x;
        int new_y = ey;
        if (move_x == 0){  
            new_x = ex;
            new_y = ey + move_y;
        }

        if (new_x >= 0 && new_x < WIDTH &&
            new_y >= 0 && new_y < HEIGHT &&
            grid[new_x][new_y] == '.'){
           
            grid[ex][ey] = '.';
            grid[new_x][new_y] = 'X';
            enemies[i].x = new_x;
            enemies[i].y = new_y;
            continue;
        }

        for (int j = 0; j < 4; j++){
            int nx = ex + directions_x[j];
            int ny = ey + directions_y[j];
           
            if (nx >= 0 && nx < WIDTH &&
                ny >= 0 && ny < HEIGHT &&
                grid[nx][ny] == '.') {
               
                grid[ex][ey] = '.';
                grid[nx][ny] = 'X';
                enemies[i].x = nx;
                enemies[i].y = ny;
                break;
            }
        }

if (grid[(int)player_x][(int)player_y] == 'X'){
            dead = 1;
return;
        }
    }
}
int any_key_pressed_check(){
int ps2kdata = *(PS2k_ptr); //read the Data register in the PS/2 port

int rvalid = (ps2kdata & 0x8000); //gets bit 15, to see if read data is valid

return rvalid;


}

/************************************************
 * INTERRUPTS FUNCTIONS
 ***********************************************/
void interrupt_init(){
int mstatus_value, mtvec_value, mie_value;
   mstatus_value = 0b1000;  // Interrupt bitmask

   // Disable interrupts
   __asm__ volatile ("csrc mstatus, %0" :: "r"(mstatus_value));
   
   mtvec_value = (int)&handler;  // Set trap address
   __asm__ volatile ("csrw mtvec, %0" :: "r"(mtvec_value));

   // Disable all interrupts that are currently enabled
   __asm__ volatile ("csrr %0, mie" : "=r"(mie_value));
   __asm__ volatile ("csrc mie, %0" :: "r"(mie_value));

   // Enable KEY, interval timer, machine timer, and SW interrupts
   mie_value = 0x810000;  //c
   __asm__ volatile ("csrs mie, %0" :: "r"(mie_value));
   
   // Enable Nios V interrupts
   __asm__ volatile ("csrs mstatus, %0" :: "r"(mstatus_value));
}
void handler(void){
   int mcause_value;
   __asm__ volatile ("csrr %0, mcause" : "=r"(mcause_value));

   //if (mcause_value == 0x80000016)  //{    // Keyboard int, 22
  //printf("keyb int in handler\n");
 // keyb_ISR(); //}
   /*else*/ if (mcause_value == 0x80000017) // Mouse int, 23
  mouse_ISR();
   else if (mcause_value == 0x80000010) // Interval timer, 16
  itimer_ISR();
}

void keyb_ISR(void){
//printf("keyb int in\n");

int ps2kdata = *(PS2k_ptr); //read the Data register in the PS/2 port

int rvalid = (ps2kdata & 0x8000); //gets bit 15, to see if read data is valid

//printf("%d\n", rvalid);

unsigned char keypressed = (ps2kdata & 0xff); //gets the pressed value and holds it

if (rvalid != 0) {
if (keypressed == 0x1D){ //up
move_player('W');
printf("w\n");
}

if (keypressed == 0x1B){ //down
move_player('S');
printf("s\n");
}

if (keypressed == 0x1C){ //turn left
move_player('A');
printf("a\n");
}

if (keypressed == 0x23){ //turn right
move_player('D');
printf("d\n");
}


audioplayer(running, 2048);
}

}
void set_ps2(void){
printf("ps2 int on\n");
volatile int* PS2k_data = (int*)0xFF200100; //PS2 DATA register
volatile int* PS2m_data = (int*) 0xff200108;

*(PS2k_data + 1) = 0x00000001; //writes 1 into PS2_Control register to enable interrupts;
*(PS2m_data + 1) = 0x00000001; //writes 1 into PS2_Control register to enable interrupts;

}
void mouse_ISR(void){

int ps2mdata = *(PS2m_ptr); // read the Data register in the PS/2 port

int rvalid = (ps2mdata & 0x8000); // gets bit 15, to see if read data is valid

unsigned int mousepressed = (ps2mdata); // gets the pressed value and holds it

printf("%d\n", mousepressed);

mousepressed = mousepressed & 0x1;

ps2mdata = 0;

if (rvalid != 0 && mousepressed == 1){

printf("mouse pressed *******\n"); //problem, it takes movement as a mouse press too

if (click){
colour = 0xffff;
click = 0;
}
else{
colour = 0xfd4c;
click = 1;
}

//draw_mouse(colour);

}

ps2mdata = 0;

}
void itimer_ISR(void){

    int new_digit;
    volatile int *timer_ptr = (int *)0xff202000;
    *timer_ptr = 0; // Clear the interrupt


total_time -= 1;

time -= 1;

digit1 = total_time % 10;

digit10 = (total_time / 10) % 10;

digit100 = (total_time / 100) % 10;

if (any_key_pressed == false){

total_time -= 1;

time += 1;

digit1 = total_time % 10;

digit10 = (total_time / 10) % 10;

digit100 = (total_time / 100) % 10;

}
}
void set_itimer(void){
    volatile int *timer_ptr = (int *)0xff202000;
    int load_val = CLOCK_RATE;
   
    *(timer_ptr + 0x2) = (load_val & 0xFFFF);
    *(timer_ptr + 0x3) = (load_val >> 16) & 0xFFFF;

    *(timer_ptr + 1) = 0x7; // STOP = 1/0 here, START = 1, CONT = 1, ITO = 1
}
ece243proj.c
Displaying ece243proj.c.